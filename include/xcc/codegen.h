#pragma once

#include <llvm/ADT/APFloat.h>
#include <llvm/ADT/STLExtras.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/Type.h>
#include <llvm/IR/Verifier.h>
#include <llvm/Passes/PassBuilder.h>
#include <llvm/Passes/StandardInstrumentations.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/Target/TargetMachine.h>
#include <llvm/Transforms/InstCombine/InstCombine.h>
#include <llvm/Transforms/Scalar.h>
#include <llvm/Transforms/Scalar/GVN.h>
#include <llvm/Transforms/Scalar/Reassociate.h>
#include <llvm/Transforms/Scalar/SimplifyCFG.h>

#include <map>

#include "xcc/jit.h"
#include "xcc/meta/value.h"
#include "xcc/meta/function.h"
#include "xcc/ast/fndecl.h"
#include "xcc/util/llvm.h"

namespace xcc::codegen {

constexpr char DEFAULT_MODULE_NAME[] = "<module>";

class ModuleContext;

/**
 * Global compiler context, holds functions/globals, global ModuleContext and JIT
 */
class GlobalContext {
public:
  /* JIT Context */
  std::unique_ptr<JIT> jit;

  /* Functions */
  std::unordered_map<std::string, std::shared_ptr<meta::Function>> functions;

  /* Current Function Name */
  std::string current_function;

  /* Global Module */
  std::shared_ptr<ModuleContext> globalModule;

  /* Global Variable Types */
  std::unordered_map<std::string, std::shared_ptr<meta::Type>> globals;

public:
  GlobalContext();
  ~GlobalContext() = default;

  static std::unique_ptr<GlobalContext> create();

  std::unique_ptr<ModuleContext> createModule(const std::string& name = DEFAULT_MODULE_NAME);

  void addModule(std::unique_ptr<ModuleContext>& module);

  void addFunction(const std::string& name, std::shared_ptr<meta::Function> fn);
  std::shared_ptr<meta::Function> getMetaFunction(const std::string& name);

  void setCurrentFunction(const std::string& name);
  void clearCurrentFunction();
  std::shared_ptr<meta::Function> getCurrentFunction();

  bool hasGlobal(const std::string& name);
  llvm::GlobalVariable * getGlobal(ModuleContext& ctx, const std::string& name);
  std::shared_ptr<meta::Type> getGlobalType(const std::string& name);

  void runExpr(std::shared_ptr<ast::Node> expr);
};

/**
 * Context for an LLVM module (basically a new one is created for every function)
 */
class ModuleContext {
public:
  /* Global Context Handle */
  GlobalContext& globalContext;

  /* Top-Level LLVM Contexts */
  struct {
    std::unique_ptr<llvm::LLVMContext> ctx;
    std::unique_ptr<llvm::Module> module;
  } llvm;

  /* LLVM IR Builder */
  std::unique_ptr<llvm::IRBuilder<>> ir_builder;

  /* Named values (variables/args) */
  std::map<std::string, std::shared_ptr<meta::TypedValue>> locals;

  /* Optimization Contexts */
  struct {
    std::unique_ptr<llvm::FunctionPassManager> fpm;
    std::unique_ptr<llvm::LoopAnalysisManager> lam;
    std::unique_ptr<llvm::FunctionAnalysisManager> fam;
    std::unique_ptr<llvm::CGSCCAnalysisManager> cgam;
    std::unique_ptr<llvm::ModuleAnalysisManager> mam;
    std::unique_ptr<llvm::PassInstrumentationCallbacks> pic;
    std::unique_ptr<llvm::StandardInstrumentations> si;
  } opt;

public:
  explicit ModuleContext(GlobalContext& global, const std::string& name = DEFAULT_MODULE_NAME);

  static std::unique_ptr<ModuleContext> create(GlobalContext& global, const std::string& name = DEFAULT_MODULE_NAME);

  llvm::Function * getFunction(const std::string& name);

  bool hasLocal(const std::string& name);
  llvm::AllocaInst * getLocalValue(const std::string& name);
  std::shared_ptr<meta::Type> getLocalType(const std::string& name);
};

/**
 * Generate a cast
 *
 * @param ctx ModuleContext
 * @param val Value to be cas
 * @param target_type LLVM Type for `val` to be cast into
 * @return Value generated by selected cast instruction
 */
llvm::Value * cast(ModuleContext& ctx, llvm::Value * val, llvm::Type * target_type);

/**
 * Calls cast() if types are not the same
 *
 * @param ctx ModuleContext
 * @param val Value to be cas
 * @param target_type LLVM Type for `val` to be cast into
 * @return If val type and target_type differ - result of cast(), otherwise - val
 */
inline llvm::Value * castIfNotSame(ModuleContext& ctx, llvm::Value * val, llvm::Type * target_type) {
  if (!util::compareTypes(val->getType(), target_type)) {
    return codegen::cast(ctx, val, target_type);
  }
  return val;
}

}

